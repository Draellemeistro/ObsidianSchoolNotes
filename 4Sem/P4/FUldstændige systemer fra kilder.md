# videnskabelige artikler
## [E-Voting: Security, Threats and Prevention](https://ieeexplore-ieee-org.zorac.aub.aau.dk/document/9768214)

##  2022: [Breaking and Fixing Vote Privacy of the Estonian E-Voting Protocol IVXV](https://orbilu.uni.lu/bitstream/10993/49442/1/main.pdf)  springer: [link](https://link.springer.com/chapter/10.1007/978-3-031-32415-4_22)
### System as is

#### Participants
- **The Election Organizer (EO)**
	- the administrator of the election who determines the list of candidates/choices, list of voters, etc. EO is also responsible for generating the public/private key material used to encrypt and eventually decrypt the voters’ choices.
- **The Vote Collector (VC)**
	- active during the ballot submission phase in which it collects the ballots submitted by the voters. VC checks incoming ballots for eligibility of the respective voter and stores all ballots according to the time at which they have been submitted
- **The I-Ballot Box Processor (IBBP)**
	- started once the submission phase has closed. IBBP takes as input the ballots collected by VC, verifies its correctness, and removes all data which is no longer needed for the subsequent tallying phase (e.g., voters’ signatures).
- **Mixing Service (MS)**
	- anonymize votes before they are decrypted by EO. MS takes as input a list of ciphertexts from IBBP, re-encrypts and shuffles this list, and returns the resulting mixed ciphertext list to EO. Any external party who wants to verify the integrity of the election result (i.e., whether the election result corresponds to the votes submitted by the voters) **can run the Data Auditor program** which takes as input all data published by the election authorities and verifies its correctness.

#### Cryptographic primitives
- **A digital signature scheme** $S = (KeyGen_S , Sign, Verify)$ for signing ballots and for signing all public data output by the election authorities.
- **A homomorphic public-key encryption scheme** $\epsilon = (KeyGen_E , Enc, Dec)$ for encrypting the voters’ plain choices. In the IVXV implementation, $\epsilon$ is instantiated with the ElGamal PKE scheme
- **A proof of shuffle** $π_{Shuffle}$ which is generated by MS to prove that it shuffled its input ciphertexts correctly. In the IVXV implementation, $π_{Shuffle}$ is instantiated with Verificatum
- **A proof of correct decryption** $π_{Dec}$ which is generated by EO to prove that it decrypted the final ciphertexts correctly. In the IVXV implementation, $π_{Dec}$ is instantiated with a Schnorr-based NIZKP to prove knowledge of discrete logarithms

In the original IVXV paper, **it had not been specified which security properties these primitives need to provide** precisely but the respective instantiations suggest that the signature scheme $S$, the encryption scheme $\epsilon$, the proof of shuffle $π_{Shuffle}$ and the proof of correct decryption $π_{Dec}$ are **==supposed to be EUF-CMA-secure, IND-CPA-secure, and non-interactive zero-knowledge proofs (NIZKPs), respectively==**
#### Faser
1. **Setup phase**: EO creates the key material
2. **Submission phase**:  voters can submit their ballots
3. **Tabulation phase**: ballots submitted by the voters are anonymized and decrypted
4. **Auditing phase**: the correctness of the data output by the election authorities can be verified externally. (*can be executed at any point after the election result has been announced.* )

##### **Setup phase**
- The protocol assumes that there exists a public-key infrastructure (PKI) of public verification keys for individual voters.
- The Election Organizer EO determines the list of eligible voters which are identified by their respective public verification keys
- EO also determines the set of valid choices C
- EO runs the key generation algorithm of the public-key encryption scheme E to obtain an encryption/decryption key pair. **lbalbla** The list of eligible voters, the set of valid choices C, as well as the public key pk are made available to everybody.

The protocol assumes that there exists a public-key infrastructure (PKI) of public verification keys for individual voters. The Election Organizer EO determines the list of eligible voters which are identified by their respective public verification keys. EO also determines the set of valid choices $C$ (i.e., party lists with individual candidates). EO runs the key generation algorithm of the public-key encryption scheme $\epsilon$ to obtain an encryption/decryption key pair  $(pk,sk) ← KeyGen_{Enc}$. The list of eligible voters, the set of valid choices $C$, as well as the public key $pk$ are made available to everybody.


##### **Submission phase**
- Each voter who wants to vote for some choice encrypts her choice
- then signs the ciphertext c with her secret signing key
- and submits the resulting pair to the Vote Collector VC
- For each incoming ballot, VC verifies whether is a valid signature for SDASD
- If this is the case, then VC stores b together with the time at which it had been submitted. Voters can re-vote multiple times.

Each voter Vi who wants to vote for some choice $ch ∈ C$ encrypts her choice as $c ← Enc(pk, ch)$, then signs the ciphertext $c$ with her secret signing key $ssk$ as $σ ← Sign(ssk, c)$ and submits the resulting pair $b ← (c, σ)$ to the Vote Collector VC. For each incoming ballot $b = (c, σ)$, VC verifies whether $σ$ is a valid signature for c w.r.t. a verification key $vk$ of one of the eligible voters. If this is the case, then VC stores $b$ together with the time at which it had been submitted. Voters can re-vote multiple times.

##### **Tabulation phase**
- After the submission phase has closed, VC forwards the list of ballots to the I-Ballot Box Processor IBBP who first verifies that all ballots in VC’s list were signed by eligible voters only.
- Afterwards, IBBP removes the ballots of all voters who have also submitted a paper vote
- Eventually, IBBP extracts the last submitted ballot of each voter (who did not submit a paper vote), removes the respective signatures, and stores the resulting ciphertexts in a list
- The I-Ballot Box Processor sends the list of ciphertexts B1 to the mixing service MS which then re-encrypts all ciphertexts in B1, shuffles the resulting re-encrypted ciphertexts uniformly at random, and computes a proof of correct shuffling
- After that, MS sends the resulting ciphertext vector B2 to EO which first uses its secret decryption key sk to decrypt all ciphertexts in B2 to obtain the final result res, and then computes a proof of correct decryption πDec to prove that it decrypted B2 correctly.

After the submission phase has closed, VC forwards the list of ballots to the I-Ballot Box Processor IBBP who first verifies that all ballots in VC’s list were signed by eligible voters only. Afterwards, IBBP removes the ballots of all voters who have also submitted a paper vote. Eventually, IBBP extracts the last submitted ballot of each voter (who did not submit a paper vote), removes the respective signatures, and stores the resulting ciphertexts in a list $B_1$.

The I-Ballot Box Processor sends the list of ciphertexts $B_1$ to the mixing service MS which then re-encrypts all ciphertexts in $B_1$, shuffles the resulting re-encrypted ciphertexts uniformly at random, and computes a proof of correct shuffling $π_{Shuffle}$.

After that, MS sends the resulting ciphertext vector $B_2$ to EO which first uses its secret decryption key $sk$ to decrypt all ciphertexts in $B_2$ to obtain the final result $res$, and then computes a proof of correct decryption $π_{Dec}$ to prove that it decrypted $B_2$ correctly.

The tuple $(B_1,B_2,\pi_{Shuffle},\pi_{Dec},res)$ is the output of the tabulation phase, where the list of plaintexts res determines the raw final election result. Eventually, EO publishes a “sanitized” version of the raw result $res$ from which all invalid choices, if any, were removed.

##### **Auditing phase**
-  The Data Auditor DA takes as input $(B_1,B_2,\pi_{Shuffle},\pi_{Dec},res)$

The Data Auditor DA takes as input $(B_1,B_2,\pi_{Shuffle},\pi_{Dec},res)$ and verifies whether $π_{Shuffle}$ is a valid proof of shuffle w.r.t. the lists of $B_1$ and $B_2$, and whether $π_{Dec}$ is a valid proof of correct decryption w.r.t. $B_2$ and $res$.


#### STUFF
Recall $\epsilon = (KeyGen_E , Enc, Dec)$ is *homomorphic* if both the message space $(M, ·)$ and the ciphertext space $(C,$⦿$)$ are (algebraic) groups and the encryption algorithm is a homomorphism between these two groups, i.e.,
$Enc(pk,m)$⦿ $Enc(pk,m')∈ Enc(pk,m·m')$ for all $(pk,sk) ∈ KeyGen_{\epsilon}$ and all $m, m' ∈ M$. For example, the ElGamal PKE scheme, the one employed in the IVXV system, is homomorphic.
==The privacy attacks presented in the remainder of this section are based on the following facts.==

> [!NOTE] Note 1
> Let E be a homomorphic public-key encryption scheme, and let (pk,sk) ∈ KeyGenE . Then the following statements hold true: 
> - For all $m_1,m_3∈M$  we have that $Enc(pk, m_1)$ ⦿$Enc(pk,m_2)∈Enc(pk, m_3)$ holds true for $m_2=m_3·{m_1}^{-1}$
> - for all $m_1,\dots, m_n ∈ M$ and all $\alpha_1,\dots,\alpha_n ∈ N$, we have $\prod^n_{i=1}Enc(pk,m_i)^{\alpha_i} ∈ Enc(pk, \prod^n_{i=1}m_{i}^{\alpha_i}$

##### Shifting Attacks (Impact: The attacker can check whether $V$ voted for $ch$)
submit a ballot which contains a vote for $ch'$ if and only if the targeted voter $V$ submitted a vote for $ch$. If $ch'$ is an unpopular choice, then the adversary learns whether or not $V$ voted for $ch$ by checking whether there exists a vote for $ch'$ in the final election result.
**We make the following assumptions:**
1. The attacker can learn the ballot of the voter $V$ whose privacy he wants to break.
2. There exists a (valid) choice $ch' ∈ C$ which is chosen by none of the (honest) voters with high probability
3. The attacker can control one voter.
**The attacker runs the following program:**
1. *Submission phase*: Learn ballot $b = (c, σ)$ of voter $V$
2. *Submission phase*: Submit ballot $b' = (c', σ')$, where $c'←c$ ⦿ $Enc(pk,ch^{-1}·ch')$
3. *After election*: Check whether $ch' ∈ res'$ 

##### Encoding Attacks (Impact: The attacker learns how $V_1, \dots , V_k$ voted)
submit a ballot which encrypts a unique encoding of the choices $ch_1, . . . , ch_k$ submitted by the targeted voters $V_1, \dots , V_k$ The attacker then checks for all possible combinations $ch'_1, \dots,ch'_k$ whether there exists an encoding of these choices in the final result. If the attacker finds such a combination, then he knows that $V_1, \dots , V_k$ voted for $ch'_1, \dots,ch'_k$ , respectively
**We make the following assumptions:**
1. The attacker can learn the ballots of the voters $V_1, \dots , V_k$ whose privacy he wants to break. 
2. The attacker can learn the raw election result $res$. 
3. The attacker can control one voter

**The attacker runs the following program:**
1. *Submission phase*: learn ballots $b_1=(c_1, σ_1),\dots,b_k=(c_k, σ_k)$ of voters $V_1, \dots , V_k$ 
2. *Submission phase*: Submit ballot $b' = (c', σ')$ where $c'←c^{\alpha_1}_1$ ⦿ $\dots$ ⦿ $c^{\alpha_k}_k$ and $\alpha_1,\dots,\alpha_k$ are integers chosen uniformly at random
3. *after election*: Let$ ch ∈ res$ be the invalid choice in the raw election result $res$. Return $ch^1,\dots,ch^k$ such that $ch=ch^{\alpha_1}_1 · .... · ch^{\alpha_k}_k$ holds ture

**Efficiency**: computational complexity of the encoding attack is $O(n^k)$, where $n$ is the number of possible choices and $k$ is the number of targeted voters. Hence, in practice, several dozen voters can be targeted efficiently. If the attacker only wants to check whether $V_1, \dots , V_k$ voted for $ch_1, \dots,ch_k$ , complexity reduces to $O(k)$

#### Pointer om systemet
- **For the shifting attack**, we assume that there exists at least one unpopular choice. this assumption is realistic.
- **For the encoding attack**, we assume that the attacker can learn the “raw” election result which also contains invalid plain choices. Threat scenario was clearly considered originally.
- **It is realistic to assume that the attacker can control a voter** because the attacker can be an eligible voter herself.

**we think that it is undesirable having to trust a party (VC: Vote Collector) for vote privacy whose original purpose/role is not to protect vote privacy (but to simply collect votes).** 
==Since VC receives all incoming messages, an attacker who controls VC can learn all submitted ballots (even if he cannot manipulate them undectably)==
it is questionable whether all parties (voters, observers, etc.) can have the same view on the data being processed, which is a crucial property for secure e-voting in general.

> [!NOTE] Why is it bad?
> vote privacy is a **universal right.** Voters must have the right to express their true will without facing personal negative consequences. **==even if vote privacy of only a fraction of the electorate can be broken, no voter can be sure whether or not she is among the targeted voters.==** This observation can be exploited to coerce many voters.
> 
> ==The mere possibility of these attacks can cause a significant bias in the election result and thus undermine the legitimacy of the government elected.==
> 
> **Fortunately, it is straightforward to protect against the privacy attacks presented.**

### Updated system
![[Pasted image 20240302213207.png]]
1. Voters in IVXV use a NIZKP $π_{Enc}$ as described above.
2. The (fixed) IVXV protocol is presented in full technical details.
3. The threat scenarios for all security properties (verifiability, privacy, coercionresistance) are described explicitly. Security is formally proven.



## ==MÅSKE???== - 2022: [How Efficient are Replay Attacks against Vote Privacy? A Formal Quantitative Analysis](https://eprint.iacr.org/2022/743)

SSSSSSSSSSS
S
S
S
S

## 2002: [Coercion-Resistant Electronic Elections](https://eprint.iacr.org/2002/165.pdf)
==We define a scheme to be _coercion-resistant_ if it is infeasible for the adversary to determine if a coerced voter complies with the demands.==
We introduce a model for electronic election schemes that involves a more powerful adversary than previous work. In particular, **we allow the adversary to demand of coerced voters that they vote in a particular manner, abstain from voting, or even disclose their secret keys.**


**previous schemes** have required use of an u**ntappable channel throughout**. **Ours** only carries the much more practical requirement of an **anonymous channel during the casting of ballots, and an untappable channel during registration** (potentially using postal mail).

## 2016: [Improving the verifiability of the Estonian Internet Voting scheme](https://research.cyber.ee/~janwil/publ/ivxv-evoteid.pdf)
security analysis identified security requirements broadly divided into the categories of:
- **integrity**
- **confidentiality**
- **transparency**
- **coercion-resistance.**
==As a starting point of our analysis, we will use the attack tree presented by Heiberg and Willemson in 7.==

## 2020: [How not to prove your election outcome](https://ieeexplore.ieee.org/document/9152765)
The Scytl/SwissPost ==e-voting solution was intended to provide complete verifiability== for Swiss government elections. **==We show failures in both individual verifiability and universal verifiability==** based on **mistaken implementations of cryptographic components.**

These failures allow for the construction of "proofs" of an accurate election outcome that pass verification though the votes have been manipulated. 
bad use of complex cryptographic algortihms can introduce **==opportunities for undetectable fraud even though the system appears to allow verification of the outcome==** .Our findings are immediately **relevant to systems in use in ==Switzerland== and ==Australia==, and probably also elsewhere.**

> [!Closing thoughts]
> We hope this work can help customers assess what does, and does not, constitute genuine verifiable computation. **==There is nothing gained by using a proven-secure component if its assumptions are not met in the context in which it is used==**==. Nor is there any advantage to sound ZKPs if they do not actually prove what is needed in the rest of the protocol.==
> 
> **==The aim of verifiable election software is verifiable election outcomes, not proofs that pass==**. **If the system itself does not come with meaningful evidence** that its verification procedure is sound, then an **apparently-successful verification implies nothing about the integrity of the election result.

> [!Fixng the problem]
> The issue needs to be corrected by ensuring that the commitment parameters are generated in a way that prevents any entity from knowing the discrete logs—==concrete suggestions are contained in Section VIII==. Every verifier then needs to check the generation of the commitment parameters as well as the rest of the proof transcript.


## 2019: [Breaking the encryption scheme of the Moscow Internet voting system](https://arxiv.org/abs/1908.05127)

> [!Hurtigt referat]
>  [Breaking the encryption scheme of the Moscow Internet voting system](https://arxiv.org/abs/1908.05127): We show **two successful attacks on the encryption scheme implemented in the voting system**
> 
> **The encryption used in this system is a variant of ElGamal over finite fields.** 
> - **In the first attack**
> 	- The used key sizes are too small. We explain how to retrieve the private keys from the public keys in a matter of minutes with easily available resources.
> -  After a fix, we found **the second attack**: 
> 	- The new implementation was not semantically secure. 
> 	- This newly found security vulnerability can be used for counting the number of votes cast for a candidate.

> [!Lessons learned] 
> 1. Designers should be careful when using cryptography
> 2. Using a blockchain is not enough to guarantee full transparency
> 
> **ALSO**
> ==This is a good example of the difficulty for an Internet voting system to make the **vote secrecy rely uniquely on cutting the link between the voters and their encrypted ballots when they arrive on a server that should also authenticate the voters.**== What is really required is to cut the link with the vote in clear, and, for this, classical methods exist like homomorphic decryption or verifiable mixnets. In such a high-stakes election, many seemingly incompatible security properties must be satisfied (secrecy vs transparency), and advanced cryptographic tools are almost impossible to avoid.

## 2010: [Attacking and fixing Helios: An analysis of ballot secrecy](https://eprint.iacr.org/2010/625)

> [!Hurtigt referat] 
> - found a vulnerability in Helios 2.0 that can be used to violate privacy. Also present fix
> - demonstrate the practicality of the attack by violating a voter's privacy in a mock election
> - feasibility of an attack in the context of French legislative elections
> 	- constitutes a real threat to ballot secrecy
> - similar vulnerabilities in other electronic voting protocols, which do not assure ballot independence.
> 	- namely, the schemes by Lee et al., Sako & Kilian, and Schoenmakers 
> 
> **==independence and privacy properties are unrelated, and non-malleability is stronger than independence.==**

## 2019: [Belenios: a simple private and verifiable electronic voting system](https://inria.hal.science/hal-02066930/document)

> [!fra abstract]
> 
> [**SYSTEM(?) SPECIFIKATION**](https://www.belenios.org/)
> 
> **We present the electronic voting protocol ==Belenios== together with its associated voting platform.**
> - Belenios guarantees vote privacy and full verifiability, even against a compromised voting server. 
> 	- It offers a good compromise between simplicity and security
> - We detail here the complete voting system from the setup to the tally and the recovery procedures. 
> - We comment on the use of Belenios in practice. In particular, we discuss the security choices made by election administrators w.r.t. the decryption key and the delegation of some setup tasks to the voting platform.

> [!Belenios explained]
> - Belenios is built upon Helios. 
> - Like in Helios, the voters can check that their ballots appear on the bulletin board, and that the result corresponds to the ballots on the board, while vote secrecy is guaranteed. 
> - In addition, Belenios provides eligibility verifiability: anyone can check that ballots come from legitimate voters, 
> 	- whereas in Helios, a dishonest bulletin board could add ballots without anyone noticing. Helios is thus vulnerable to ballot stuffing. 
> 	- **Eligibility verifiability can be added to voting systems through a signature mechanism and additional credentials**
> - like in Helios, Belenios is not coercion-resistant: voters may prove for whom they voted by providing the randomness used to produce their ballot or they may simply sell their voting material. Therefore Belenios should not be used in high stake elections.


> [!Implementation and design decisions]
> - **Belenios involves several entities:** voters, of course, but also a registrar, and decryption trustees. None of these roles require special cryptographic skills. 
> - We therefore describe here which adaptions had to be made for our system to be usable. 
> - our voting platform offers **several levels of security**: 
> 	- the registration may be done directly by the voting server, 
> 	- the decryption key may or may not be split into several shares.
> -  **This yields different tradeoffs between security and simplicity**

## #TODO 2008: [Helios: Web-based Open-Audit Voting](https://www.usenix.org/legacy/events/sec08/tech/full_papers/adida/adida.pdf) 

## 2007: [Civitas: Toward a Secure Voting System](https://www.cs.cornell.edu/andru/papers/civitas-tr.pdf)

> [!highlights fra abstract]
> - ==Civitas is the first electronic voting system that is==:
>  - **coercion-resistant**, 
>  - **universally and voter verifiable**, 
>  - **suitable for remote voting**. 
>  
>   This paper describes the design and implementation of Civitas. 
>   security proofs for design, information-flow security analysis for implementation. 
>   Evaluation of the tradeoffs between time, cost, and security.


> [!Developing Civitas led to several contributions:] 
> - A provably secure voter registration protocol, which distributes trust over a set of registration authorities.
> - A scalable design for vote storage that ensures integrity without expensive fault tolerance mechanisms.
> - A performance study demonstrating the scalability of secure tabulation.
> - A coercion-resistant construction for implementing a ranked voting method.
> - A concrete, publicly available specification of the cryptographic protocols required to implement a coercion-resistant, verifiable, remote voting scheme. This specification leverages many results in the cryptographic and voting literature.

> [!Requirements]
> **First**, in some circumstances, voters must register at least partly in person. 
> **Second**, voters must trust the computational device they use to submit votes
> 
> **Verifiability**. The final tally is verifiably correct. Each voter can check that their own vote is included in the tally (voter verifiability). Anyone can check that all votes cast are counted, that only authorized votes are counted, and that no votes are changed during counting (universal verifiability). ==for confidentiality==
> 
> **Coercion Resistance.** Voters cannot prove whether or how they voted, even if they can interact with the adversary while voting



> [!Threat model.] 
> **We require Civitas to be secure with respect to an adversary with the following capabilities:**
> - The adversary may corrupt a threshold of the election authorities, mutually distrusting agents who conduct an election. Agents might be humans, organizations, or software components.
> - The adversary may coerce voters, demand their secrets, and demand any behavior of them— remotely or in the physical presence of voters. But the adversary may not control a voter throughout an entire election, otherwise the voter could never register or vote.
> - The adversary may control all public channels on the network. However, we also assume the existence of some anonymous channels, on which the adversary cannot identify the sender, and some untappable channels, which the adversary cannot use at all.
> - The adversary may perform any polynomial-time computation.


> [!Civitas Architecture]
> ![[Pasted image 20240303030151.png]]


> [!Agents]
> five kinds of agents in the Civitas voting scheme: a **supervisor**, a **registrar**, **voters**, **registration tellers**, and **tabulation tellers**. Other than voters, all are elecion authorities:
> - The **supervisor** administers an election. This includes specifying the ballot design and the tellers, and starting and stopping the election
> - The **registrar** authorizes voters.
> - **Registration tellers** generate the credentials that voters use to cast their votes
> - **Tabulation tellers** tally votes.
> These agents use an underlying **==log service==** that implements publicly readable, insert-only storage.



> [!log service]
> Publicly readable, insert-only storage. Integrity of messages in a log is ensured by digital signatures. Agents may sign messages they insert, ensuring that the log service cannot forge new messages. The log service must sign its responses to reads, ensuring that attempts to present different views of log contents to different readers can be detected. Multiple instances of the log service are used in a single election. **==One instance, called the bulletin board==, is used by election authorities to record all the information needed for verifiability of the election. ==The remaining instances, called ballot boxes==, are used by voters to cast their votes.**


> [!NOTE] Other things of note
> - Descriptions and walkthrough of the different phases in the election
> - Security evaluation
> - Cryptographic components
> - secuirt proof
> - generelt bare gennemgang af opbygningen af systemet


> [!NOTE] trust assumptions
> 1. The adversary cannot simulate a voter during registration.
> 2. Each voter trusts at least one registration teller, and the channel from the voter to the voter’s trusted registration teller is untappable.
> 3. Voters trust their voting clients.
> 4. The channels on which voters cast their votes are anonymous.
> 5. At least one of the ballot boxes to which a voter submits his vote is correct
> 6. There exists at least one honest tabulation teller
> 7. **Nævnt senere:** The Decision Diffie-Hellman (DDH) and RSA assumptions hold, and SHA256 implements a random oracle.


> [!Attacks on election authorities.]
>  **Trust Assumptions 2, 5, and 6** allow all but one election authority of each kind to be corrupted. But certain attacks might still be mounted:
>  - A corrupt registration teller might fail to issue a valid credential share to a voter. The voter can detect this, but coercion resistance requires that the voter cannot prove that a share is valid or invalid to a third party. Defending against this could involve the voter and another election authority, perhaps an external auditor, jointly attempting to re-register the voter. The auditor could then attest to the misbehavior of a registration teller.
>  - The bulletin board might attempt to alter messages. But this is detectable since messages are signed. A bulletin board might also delete messages. This is an attack on availability, which is addressed in Section 11.
>  - A corrupt registrar might add fictitious voters or remove legitimate voters from the electoral roll. Each tabulation teller can defend against this by refusing to tabulate unless the electoral roll is correct according to some external policy.
>  - A corrupt supervisor might post an incorrect ballot design, stop an election early, or even attempt to simulate an election with only one real voter. Voters and tabulation tellers should cease to participate in the election once the supervisor exhibits such behavior.
>
>All election authorities might be simultaneously corrupted if they all run the same software. For example, an insider working at the software supplier might hide malicious code in the tabulation teller software. As discussed in Trust Assumption 6, this attack could violate coercion resistance, but it could not violate verifiability. To defend against insider attacks, election authorities should use diverse implementations of the Civitas protocols.

> [!Different Cryptographic voting schemes]
> **Cryptographic voting schemes can be divided into three categories, based on the technique used to anonymize votes**
> - **homomorphic encryption**, voters submit encrypted votes that are never decrypted. Rather, the submitted ciphertexts are combined (using some operation that commutes with encryption) to produce a single ciphertext containing the election tally, which is then decrypted.
> - **Blind signature schemes** split the election authority into an authenticator and tallier. The voter authenticates to the authenticator, presents a blinded vote, and obtains the authenticator’s signature on the blinded vote. The voter unblinds the signed vote and submits it via an anonymized channel to the tallier
> - **mix network schemes** voters authenticate and submit encrypted votes. Votes are anonymized using a mix, and anonymized votes are then decrypted. JCJ and Civitas are both based on mix networks

> [!Andre Pointer]
> - [Smith](https://rangevoting.org/WarrenSmithPages/homepage/crirv.pdf) proposes implementations of single transferrable vote (STV) and range voting that defend against Italian attacks(**Coercion**). [Heather](https://dl.acm.org/doi/10.1109/CSF.2007.22) proposes an implementation of STV for Pretˆ a Voter.
> - Finally, a report on the security of a real-world remote voting system, [SERVE, identifies a number of open problems in electronic voting](https://www.acm.org/binaries/content/assets/public-policy/usacm/e-voting/reports-and-white-papers/serve_report_full_paper.pdf)**These problems include**: 
> 	- transparency of voter clients, 
> 	- vulnerability of voter clients to malware, 
> 	- vulnerability of the ballot boxes to denial-of-service attacks that could lead to large-scale or selective disenfranchisement.


##  ==MÅSKE??== 2013: [Privacy and verifiability in voting systems: Methods, developments and trends](https://www.sciencedirect.com/science/article/abs/pii/S1574013713000282)



## 2013: [STAR-Vote: A Secure, Transparent, Auditable, and Reliable Voting System](https://www.usenix.org/system/files/conference/evtwote13/jets-0101-bell.pdf)

## ==GAMMEL, MEN MEGET INFO, GOD??== 1987: [Verifiable Secret-Ballot Elections](https://cpsc.yale.edu/sites/default/files/files/tr561.pdf)

## [A Scheme for Three-way Secure and Verifiable E-Voting](https://ieeexplore-ieee-org.zorac.aub.aau.dk/document/8612810)
**HAR:**
- Secure voting framework
- voting protocols
- security analysis
- implementation
- performance analysis

## [Verifiable receipt-free electronic voting system based on mask ballot](https://ieeexplore-ieee-org.zorac.aub.aau.dk/document/9724582)
### Our Proposed Scheme

## [A Toolbox for Verifiable Tally-Hiding E-Voting Systems](https://kbdk-aub.primo.exlibrisgroup.com/permalink/45KBDK_AUB/159qapk/cdi_openaire_primary_doi_366b88213911146acc9a1a32f8d1ed10)


## [Ordinos: A Verifiable Tally-Hiding E-Voting System](https://www.computer.org/csdl/proceedings-article/euros&p/2020/508700a216/1oqKxJjEIUM)


## 2019/2023: [Towards End-to-End Verifiable Online Voting: Adding Verifiability to Established Voting Systems](https://kbdk-aub.primo.exlibrisgroup.com/permalink/45KBDK_AUB/159qapk/cdi_crossref_primary_10_1109_TDSC_2023_3327859)også [her?](https://www.computer.org/csdl/journal/tq/5555/01/10298802/1RADozid6p2)


## 2018: [SHARVOT: Secret SHARe-Based VOTing on the Blockchain](https://kbdk-aub.primo.exlibrisgroup.com/permalink/45KBDK_AUB/159qapk/cdi_ieee_primary_8445055) også [her](https://www.computer.org/csdl/proceedings-article/wetseb/2018/572601a030/13bd1fph1yP)


## [Alethea: A Provably Secure Random Sample Voting Protocol](https://kbdk-aub.primo.exlibrisgroup.com/permalink/45KBDK_AUB/159qapk/cdi_ieee_primary_8429312) også [her](https://www.computer.org/csdl/proceedings-article/csf/2018/668001a283/12OmNzZWbAn)

## 2012: [A conceptual approach to secure electronic elections based on patterns](https://www.sciencedirect.com/science/article/abs/pii/S0740624X12001360) primo [link](https://kbdk-aub.primo.exlibrisgroup.com/permalink/45KBDK_AUB/159qapk/cdi_openaire_primary_doi_6522e101e77c6af847f46e7bd0f8bcc3)
**HAR:**
- election setup snak
- systemet
- klasse diagram (under)
	- her: ![[Pasted image 20240303144324.png]]
- aktivitets diagram (under)
	- her:
	   ![[Pasted image 20240303144404.png]]
- Security requirements
- Design stage
- Diskussion angående kravene

## 2010: [Towards Trustworthy Elections](https://kbdk-aub.primo.exlibrisgroup.com/permalink/45KBDK_AUB/159qapk/cdi_openaire_primary_doi_fe4dcf889188cd36d54e6094636a3f9f)
### MANGE GODE TING HER
#### [The Witness-Voting System](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_1)
new, comprehensive framework to qualitatively improve election outcome trustworthiness, where voting is modeled as an information transfer process. 
- **Error considerations**, including **faults**, **attacks**, and t**hreats by adversaries**, are explicitly included.
- **Sixteen voting system requirements**, including **functional**, **performance**, **environmental** and **non-functional** considerations, are derived and rated, meeting or exceeding current public-election requirements.
- **The voter and the vote are unlinkable** (secret ballot) although each is identifiable.

The Witness-Voting System (Gerck, 2001) is extended as a conforming implementation of the provably optimal design that is **error-free**, **transparent**, **simple**, **scalable**, **robust**, **receipt-free**, **universally-verifiable**, **100% voter-verified**, and **end-to-end audited**.
#### [Coercion-Resistant Electronic Elections](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_2)
 model for electronic election schemes that involves a more powerful adversary than previous work. 
 - describes and characterize this newly strengthened adversary.
 - a protocol that is provably secure against our formalized adversary
 - We model real-life threats (such as vote-buying)
 - proposed protocol combines a fair degree of efficiency with low structural complexity
 - While previous schemes have required an untappable channel, ours has the more practical requirement of an anonymous channel.

#### [Receipt-Free _K_-out-of-_L_ Voting Based on ElGamal Encryption](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_3)
We present a _K_-out-of-_L_ voting scheme, i.e., a voting scheme that allows every voter to vote for (up to) _K_ candidates from a set of _L_ candidates. 
- The scheme is receipt-free, which means that even a malicious voter cannot prove to anybody how he voted.
- the scheme can be based on any semantically secure homomorphic encryption scheme
- **n contrast to the standard setting with receipts, in a receipt-free setting a _K_-out-of-_L_ voting scheme cannot be derived directly from a yes/no voting scheme.**

#### [A Secure Architecture for Voting Electronically (SAVE)](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_4)
 
 - The Secure Architecture for Voting Electronically (SAVE) is one proposed architecture for mitigating security and trust issues with the voting process.
 - the architecture enables academics, small companies and organizations to easily and cheaply build their own modules conforming to the standard.
**HAR:**
1.  Security Requirements and Desires for the Voting Process
2. Background Reliability of Electronic Devices
3. groups of actors interested in compromising the system
4. angreb (på fysiske stemmesedler?)
5. systemets (SAVE) arkitektur
6. crypto protocols
7. sikkerhedsanalyse

#### [A Modular Voting Architecture (“Frog Voting”)](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_5)
new framework–a reference architecture–for voting that we feel has many attractive features. It is not a machine design, but rather a framework that will stimulate innovation and design. It is potentially the standard architecture for all future voting equipment.
**HAR:**
1. beskrivelse af systemopbygning
2. de forskellige faser i et valg og frog systemet 

#### [Unconditionally Secure Electronic Voting](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_6)
how to achieve unconditional or information-theoretic security in electronic voting with the f**ollowing property**:
- Even all voters and tallying authorities have unbounded computing power, the distorted integrity of the voting results can be detected and proved incorrect by every honest voter,
- If at least one tallying authority is honest, then the privacy of the ballots are protected everlastingly even the other voters and tallying authorities are malicious and have the unbounded computing power.
**We assume single trusted authority who honestly delivers a particular form of secret key to every voter and tallying authority**. This authority can be destroyed before the election is started. Two information-theoretic primitives are introduced based on this pre-distributed secret key, unconditionally secure oblivious polynomial evaluation (US-OPE) and unconditionally secure publicly verifiable secret sharing (US-PVSS). These primitives make the election process unconditionally secure in the above sense and efficient. **==The resulting scheme requires in a case of 1 million voters, the storage complexity to store private key required for each voter is 300MB. Communication complexity to verify the whole tallying process (the heaviest part) is 27GB in a case of tolerating up to 1000 colluding users, and 220GB in a case of tolerating up to 10,000 colluders.==**

**HAR:**
- math, lots of it
- proofs
- modelering af systemet
- efficiency

#### [An Implementation of a Mix-Net Based Network Voting Scheme and Its Use in a Private Organization](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_8)
discuss an implementation of a network voting scheme based on mix-net technology. The system has been employed in a private organization with roughly 20,000 voters since 2004
**HAR:**
- Systemopbygning / arkitektur
- protocol gennemgang
- proofs
- Resultater af implementering
- brug i en privat virksomhed / org

#### [The Vector-Ballot Approach for Online Voting Procedures](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_9)
Looking at current cryptographic-based e-voting protocols, one can distinguish three basic design paradigms:
1. Mix-Networks based
2. Homomorphic Encryption based
3. Blind Signatures based
Each of the three possesses different advantages and disadvantages w.r.t. the _basic properties_ of (i) efficient tallying, (ii) universal verifiability, and (iii) allowing write-in ballot capability (in addition to predetermined candidates) **none of the approaches results in a scheme that simultaneously achieves all three.**

 this paper suggest a new _“vector-ballot” based approach_ for secret-ballot e-voting that is based on three new notions: 
 1. **_Provably Consistent Vector Ballot Encodings_**
 2. **_Shrink-and-Mix Networks_** 
 3. **_Punch-Hole-Vector-Ballots_**

 **HAR:**
- proofs
- arkitektur / opbygning
- antagelser 
- setup
- egenskaber ved deres løsning
- sammenligning med tidligere løsninger
- gennemgang af de forskellige faser i systemet og valget

#### [Anonymous One-Time Broadcast Using Non-interactive Dining Cryptographer Nets with Applications to Voting](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_14)
**All voting protocols proposed so far, with the exception of a few, have the property that the privacy of the ballot is only computational.** we outline a new and conceptually simple approach allowing us to construct a protocol in which the privacy of the ballot is unconditional.
**==basic idea:==**
- modify the protocol of [Fujioka, Okamoto and Ohta (A practical secret voting scheme for large scale elections)](https://scholar-google-com.zorac.aub.aau.dk/scholar_lookup?&title=A%20practical%20secret%20voting%20scheme%20for%20large%20scale%20elections&pages=244-251&publication_year=1993&author=Fujioka%2CA.&author=Okamoto%2CT.&author=Ohta%2CK.) which uses blind signatures so that the voter can obtain a valid ballot.
- instead of using a MIX net, we use a new broadcast protocol for anonymously publishing the vote, a Non-Interactive variation of the Dining Cryptographer Net.

the well-known Dining Cryptographers protocol, which, as far as we know, has not been published before, and is of separate interest. T**hough the basic idea is simple, some technical subtleties need to be resolved** since, unlike the original protocol, there is only one round. In the next section we will give **a high level sketch of the proposed voting protocol**, whereas S**ection 3 contains a detailed description of the non-interactive variation of the Dining Cryptographers protocol.**

#### [Component Based Electronic Voting Systems](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_16)
**Keywords**
- [Human Layer](https://link-springer-com.zorac.aub.aau.dk/search?query=Human%20Layer&facet-discipline=%22Computer%20Science%22)
- [Secure Socket Layer](https://link-springer-com.zorac.aub.aau.dk/search?query=Secure%20Socket%20Layer&facet-discipline=%22Computer%20Science%22)
- [Publishing Strategy](https://link-springer-com.zorac.aub.aau.dk/search?query=Publishing%20Strategy&facet-discipline=%22Computer%20Science%22)
- [Electronic Vote](https://link-springer-com.zorac.aub.aau.dk/search?query=Electronic%20Vote&facet-discipline=%22Computer%20Science%22)
- [Computational Complexity Analysis](https://link-springer-com.zorac.aub.aau.dk/search?query=Computational%20Complexity%20Analysis&facet-discipline=%22Computer%20Science%22)

An electronic voting system may be said to be **composed of a number of components**, each of which has a number of properties. **==One of the most attractive effects of this way of thinking is that each component may have an attached in-depth threat analysis and verification strategy.==**
the need to include the full system when making changes to a component is minimised and a model at this level can be turned into a lower-level implementation model where changes can cascade to as few parts of the implementation as possible.

#### [A Verifiable Voting Protocol Based on Farnel](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_17)
**Keywords**
- [security](https://link-springer-com.zorac.aub.aau.dk/search?query=security&facet-discipline=%22Computer%20Science%22)
- [voting protocols](https://link-springer-com.zorac.aub.aau.dk/search?query=voting%20protocols&facet-discipline=%22Computer%20Science%22)
- [voter verification](https://link-springer-com.zorac.aub.aau.dk/search?query=voter%20verification&facet-discipline=%22Computer%20Science%22)
- [paper-based](https://link-springer-com.zorac.aub.aau.dk/search?query=paper-based&facet-discipline=%22Computer%20Science%22)
- [Farnel](https://link-springer-com.zorac.aub.aau.dk/search?query=Farnel&facet-discipline=%22Computer%20Science%22)
Farnel is a voting system proposed in 2001 in which each voter signs a ballot. It uses two ballot boxes to avoid the association between a voter and a vote. In this paper we first point out a flaw in the ThreeBallot system proposed by Rivest that seems to have gone unnoticed so far: it reveals statistical information about who is winning the election. Then, trying to resolve this and other flaws, we present a new, voter-verifiable version of the Farnel voting system in which voters retain copies of ballot IDs as receipts.

#### [Improving Remote Voting Security with CodeVoting](https://link-springer-com.zorac.aub.aau.dk/chapter/10.1007/978-3-642-12980-3_19)
 **Keywords**
- [Remote voting](https://link-springer-com.zorac.aub.aau.dk/search?query=Remote%20voting&facet-discipline=%22Computer%20Science%22)
- [Internet voting](https://link-springer-com.zorac.aub.aau.dk/search?query=Internet%20voting&facet-discipline=%22Computer%20Science%22)
- [vote manipulation](https://link-springer-com.zorac.aub.aau.dk/search?query=vote%20manipulation&facet-discipline=%22Computer%20Science%22)
- [uncontrolled voting platform](https://link-springer-com.zorac.aub.aau.dk/search?query=uncontrolled%20voting%20platform&facet-discipline=%22Computer%20Science%22)
- [insecure voting platform](https://link-springer-com.zorac.aub.aau.dk/search?query=insecure%20voting%20platform&facet-discipline=%22Computer%20Science%22)
ne of the major problems that prevents the spread of elections with the possibility of remote voting over electronic networks **is the use of unreliable client platforms, such as the voter’s computer and the Internet infrastructure connecting it to the election server.** A computer connected to the Internet is exposed to viruses, worms, Trojans, spyware, malware and other threats that can compromise the election’s integrity.
- possible to write a virus that changes the voter’s vote to a predetermined vote on election’s day.
- possible attack is the creation of a fake election web site where the voter uses a malicious vote program on the web site that manipulates the voter’s vote (phishing/pharming attack).
- Such attacks may not disturb the election protocol, therefore can remain undetected in the eyes of the election auditors.

==CodeVoting consists in creating a secure communication channel to communicate the voter’s vote between the voter and a trusted component attached to the voter’s computer. no one controlling the voter’s computer can change the his/her’s vote. The trusted component can then process the vote according to a cryptographic voting protocol to enable cryptographic verification at the server’s side.==
# TEKNISKE TING
## 2021/2022: Gitlab [E-voting documentation](https://gitlab.com/swisspost-evoting/e-voting/e-voting-documentation)
ASDASDASDASD
